```{r}
---
title: "Lab 7 assignment: Group 06"
format: 
  html:
    embed-resources: true
editor: visual
---
```

#### Group members

| Name                  | ID      |
|-----------------------|---------|
| Arne Hellhund         | arnhell |
| Magdalena Dzierzynska | s194428 |
| Lasse Buhl            | s215025 |
| Saxe Wagner           | s204559 |
| Antonio Mocinic       | s243171 |

## Microreport

This report follows a code-along from this [post on PCA in tidyverse](https://clauswilke.com/blog/2020/09/07/pca-tidyverse-style/).

The following is copied directly from the above linked post.

Doing a PCA in R is easy: Just run the function `prcomp()` on your matrix of scaled numeric predictor variables. There’s just one problem, however. The result is an object of class `prcomp` that doesn’t fit nicely into the tidyverse framework, e.g. for visualization. While it’s reasonably easy to extract the relevant info with [some base-R manipulations,](https://wilkelab.org/classes/SDS348/2020_spring/worksheets/class9_solutions.html) I’ve never been happy with this approach. But now, I’ve realized that all the necessary functions to do this tidyverse-style are available in the broom package.

### Loading libraries

```{r, message=FALSE, running=FALSE}
library("tidyverse")
library("broom") 
#devtools::install_github
#("tidymodels/broom")
library("cowplot")
```

#We’ll be analyzing the `biopsy` dataset, which comes originally from the MASS package. It is a breast cancer dataset from the University of Wisconsin Hospitals, Madison from Dr. William H. Wolberg. He assessed biopsies of breast tumors for 699 patients; each of nine attributes was scored on a scale of 1 to 10. The true outcome (benign/malignant) is also known.

### Loading data from url

```{r}
#Read and save data to 'biopsy'
biopsy <- read_csv(file = "https://wilkelab.org/classes/SDS348/data_sets/biopsy.csv")
```

### Performing PCA

In general, when performing PCA, we’ll want to do (at least) three things:

1.  Look at the data in PC coordinates.

2.  Look at the rotation matrix.

3.  Look at the variance explained by each PC.

Let’s do these three things in turn.

## Look at the data in PC coordinates

We start by running the PCA and storing the result in a variable `pca_fit`. All non-numeric columns are removed using `where(is.numeric)`, since the `prcomp()` function can only deal with numeric columns. Prior to running PCA, the data values are scaled to unit variance, using the argument `scale = TRUE` in `prcomp()`.

```{r}
pca_fit <- biopsy |> 
  select(where(is.numeric)) |> # retain only numeric columns
  prcomp(scale = TRUE) # do PCA on scaled data
```

The PCs are plotted, by combining the PCs with the original dataset, allowing us to stratefy the PCs by color to categorical variables. The function `augment()` from broom takes the fitted model and the original data as arguments, combining the two datasets. The columns containing the fitted coordinates are called `.fittedPC1`, `.fittedPC2`, etc.

```{r}
pca_fit |> 
  augment(biopsy) |>  # add original dataset back in
  ggplot(mapping = aes(.fittedPC1, .fittedPC2, color = outcome)) + 
  geom_point(size = 1.5) +
  scale_color_manual(
    values = c(malignant = "#D55E00", benign = "#0072B2")
  ) +
  theme_half_open(12) + background_grid()
```

## Look at the data in PC coordinates

The rotation matrix is stored as `pca_fit$rotation`

Next, we plot the rotation matrix. The rotation matrix is stored as 'rotation' in the 'pca_fit' tibble. The matrix is extracted using the `tidy()` function from broom. When applied to `prcomp` objects, the `tidy()` function takes an additional argument `matrix`, which is set to `matrix = "rotation"` to extract the rotation matrix.

```{r}
# extract rotation matrix
pca_fit |> 
  tidy(matrix = "rotation")
```

Now in the context of a plot:

```{r}
# define arrow style for plotting
arrow_style <- arrow(angle = 20,
                     ends = "first",
                     type = "closed",
                     length = grid::unit(8, "pt")
)

# plot rotation matrix
pca_fit |> 
  tidy(matrix = "rotation") |> 
  pivot_wider(names_from = "PC",
              names_prefix = "PC",
              values_from = "value") |> 
  ggplot(aes(PC1, PC2)) +
  geom_segment(xend = 0,
               yend = 0,
               arrow = arrow_style) +
  geom_text(
    aes(label = column),
    hjust = 1, nudge_x = -0.02, 
    color = "#904C2F"
  ) +
  xlim(-1.25, .5) + ylim(-.5, 1) +
  coord_fixed() + # fix aspect ratio to 1:1
  theme_minimal_grid(12)

```

## Look at the variance explained by each PC

\##

## Cumulative variance explained in PCA

Now, we are going to plot a cumulative variance plot. It explains how much of the variation in the data is captured within the first *x* components. A threshold of 90% is often used to make a reduction in dimensionality without losing too much information. 

```{r}
pca_fit |>
  tidy(matrix = "eigenvalues") |> 
  ggplot(aes(x = PC, y = cumulative ))+
  geom_point()+
  geom_line()+
  scale_x_continuous(breaks = 1:9) +
   scale_y_continuous(labels = scales::label_percent())+
  geom_hline(yintercept = 0.9, linetype="dashed", color="orange", size = 1)+
  labs(title = "Cumulative variance explained in PCA",
       x = "PCA components",
       y = "cumulative variance"
       )+
  theme_minimal()+
  theme(panel.grid.minor = element_blank())

  
 
```
